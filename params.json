{
  "name": "Mysqltest",
  "tagline": "only code",
  "body": "# 数据库编程实例\r\n\r\n标签（空格分隔）： java\r\n\r\n---\r\n\r\n## 数据库的连接\r\n老实说，搞了很久，因为没有添加mysql提供的驱动工具包，。，。，。，幸好能够独立思考了，。\r\n\r\n```java\r\n\r\n/**\r\n * Created by XQF on 2016/12/1.\r\n */\r\npublic class DBConnection {\r\n    String dbDriver = \"com.mysql.jdbc.Driver\";\r\n    String dbUrl = \"jdbc:mysql://localhost:3306/first_db?useSSL=false\";\r\n    String userName = \"root\";\r\n    String userPassword = \"125880\";\r\n    Connection connection = null;\r\n//\r\n\r\n    /**\r\n     * 在构造方法中就把事情办了，当然上面的这些字段也可以写作为方法里的临时变量，但是我认为还是放在类中的字段比较好，方便复用嘛，\r\n     * 不过说复用好像也没有复用到哪里，因为Connection是通过静态方法来获取的。也就是说创建connection的过程中一定要有方法的调用，\r\n     * 尽管可能是构造方法.当然写成名字比较好认的方法也是比较舒适\r\n     */\r\n    public DBConnection() {\r\n        try {\r\n            Class.forName(dbDriver);\r\n            System.out.println(\"Driver success!! \");\r\n            connection = DriverManager.getConnection(dbUrl, userName, userPassword);\r\n        } catch (ClassNotFoundException e) {\r\n            System.out.println(\"Driver failure!\");\r\n        } catch (SQLException e) {\r\n            System.out.println(\"Connection failure!\");\r\n        }\r\n    }\r\n\r\n    public void closeConnection() {\r\n        if (connection != null) {\r\n            try {\r\n                connection.close();\r\n                System.out.println(\"close database success!\");\r\n            } catch (SQLException e) {\r\n                System.out.println(\"close failure!!\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        DBConnection myDBConnection = new DBConnection();\r\n        myDBConnection.closeConnection();\r\n    }\r\n}\r\n\r\n \r\n```\r\n\r\n\r\n\r\n\r\n## 创建表\r\n最开始的是跟着例子使用Statement的executeUpdate()方法，不过这个方法不是用于更改吗，所以我使用了execute()方法改进，还简化了后面的成功判断。\r\n```java\r\n\r\n/**\r\n * Created by XQF on 2016/12/1.\r\n */\r\npublic class CreateTable {\r\n    Connection connection = null;\r\n    private Statement stmt = null;\r\n    public static final String CREATE_TABLE = \"create table students(Sno char(10),Sname char(20),Sage int,Smajor char(10))\";\r\n\r\n    public boolean createStudentTable() {\r\n        connection = new DBConnection().getConnection();\r\n        boolean returnResult = true;\r\n        try {\r\n            stmt = connection.createStatement();\r\n            stmt.executeUpdate(CREATE_TABLE);\r\n            //stmt.execute(CREATE_TABLE);\r\n            stmt.close();//好习惯\r\n            connection.close();//好习惯\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读异常！\");\r\n            returnResult = false;\r\n        }\r\n        return returnResult;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        CreateTable createTable = new CreateTable();\r\n        boolean isCreateSuccess = createTable.createStudentTable();\r\n        if (isCreateSuccess) {\r\n            System.out.println(\"创建表成功\");\r\n        } else {\r\n            System.out.println(\"创建表不成功\");\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n改进：\r\n```java\r\n\r\n\r\n/**\r\n * Created by XQF on 2016/12/1.\r\n */\r\npublic class CreateTable {\r\n    Connection connection = null;\r\n    private Statement stmt = null;\r\n    public static final String CREATE_TABLE = \"create table students(Sno char(10),Sname char(20),Sage int,Smajor char(10))\";\r\n\r\n    public boolean createStudentTable() {\r\n        connection = new DBConnection().getConnection();\r\n        boolean returnResult = true;\r\n        try {\r\n            stmt = connection.createStatement();\r\n            returnResult=stmt.execute(CREATE_TABLE);\r\n            stmt.close();\r\n            connection.close();\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读异常！\");\r\n            returnResult = false;\r\n        }\r\n        return returnResult;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        CreateTable createTable = new CreateTable();\r\n        boolean isCreateSuccess = createTable.createStudentTable();\r\n        if (isCreateSuccess) {\r\n            System.out.println(\"创建表成功\");\r\n        } else {\r\n            System.out.println(\"创建表不成功\");\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n### 总结\r\n\r\n> 注意好习惯就是先把Statement关闭掉，再关闭掉Connection.，。，注意到我把SQL语句分行写居然给我报错。不过隔行后要加引号，原来如此。\r\n\r\n\r\n## 添加数据信息\r\n\r\n```java\r\n\r\n/**\r\n * Created by XQF on 2016/12/1.\r\n */\r\npublic class InsertRecord {\r\n    private static final String INSERT_DATA = \"insert into students values('130063','xqf',20,'CS')\";\r\n    private Connection connection;\r\n    private Statement stmt;\r\n    private PreparedStatement pstmt;\r\n\r\n    public boolean addStudentDataInfo() {\r\n        connection = new DBConnection().getConnection();\r\n        boolean insertResult = true;\r\n        try {\r\n            stmt = connection.createStatement();\r\n            stmt.executeUpdate(INSERT_DATA);\r\n            stmt.close();\r\n            connection.close();\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读异常！\");\r\n            insertResult = false;\r\n        }\r\n        return insertResult;\r\n    }\r\n\r\n    public int addStudentDataInfo(String Sno, String Sname, int Sage, String Smajor) {\r\n        int count = 0;\r\n        boolean insertResult = true;\r\n        connection = new DBConnection().getConnection();\r\n        String insertSqlString = \"insert into students values(?,?,?,?)\";\r\n\r\n        try {\r\n            pstmt = connection.prepareStatement(insertSqlString);\r\n            pstmt.setString(1, Sno);\r\n            pstmt.setString(2, Sname);\r\n            pstmt.setInt(3, Sage);\r\n            pstmt.setString(4, Smajor);\r\n            count = pstmt.executeUpdate();\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读异常！\");\r\n        } finally {\r\n            try {\r\n                pstmt.close();\r\n                connection.close();\r\n            } catch (SQLException e) {\r\n                System.out.println(\"在关闭数据的时候遇到异常，异常信息为\" + e.getMessage());\r\n            }\r\n\r\n        }\r\n        return count;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        InsertRecord insertRecord = new InsertRecord();\r\n        boolean isInsertSucesss = insertRecord.addStudentDataInfo();\r\n        if (isInsertSucesss) {\r\n            System.out.println(\"数据添加成功\");\r\n        } else {\r\n            System.out.println(\"数据添加不成功\");\r\n        }\r\n        int count = insertRecord.addStudentDataInfo(\"9527\", \"wly\", 20, \"CS\");\r\n        System.out.println(count + \"条记录被添加\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 总结\r\n\r\n> 抄一下代码还是能学到多，这里相当于是对比了一下Statement与PrepareStatement，明显PrepareStatement更加灵活，有利于多次操作。另外在捕获异常的时候也是把异常分开也可以非常准确的报告错误。还有一点的是，Statement和PrepareStatement的方法虽然名字相同，但是使用的方式是绝对不一样，比如\r\n> Statement的executeUpate(sqlString）方法有参数，而PrepareStatement的executeUpdate（）方法就没有参数。这个方法的返回参数应该就是\r\n\r\n    (1) SQL 数据操作语言 (DML) 语句的行数 (2) 对于无返回内容的 SQL 语句，返回 0 \r\n    \r\n    \r\n\r\n> 至于操作语言语句行数一般是在循环中，用一个PrepareStatement不停的添加。整个过程也是贯彻了方法只有一个出口的理念。catch块和try块相当于是不同的作用域。\r\n\r\n\r\n## 数据信息的删除\r\n```java\r\n\r\n/**\r\n * Created by XQF on 2016/12/2.\r\n */\r\n\r\npublic class DeleteRecord {\r\n    private Connection connection = null;\r\n    private PreparedStatement pstmt = null;\r\n    private static final String sqlString = \"delete from students where Sno=?\";\r\n\r\n    public int deleteOneStudent(String Sno) {\r\n        int count = -1;\r\n        connection = new DBConnection().getConnection();\r\n        try {\r\n            pstmt = connection.prepareStatement(sqlString);\r\n            pstmt.setString(1, Sno);\r\n            count = pstmt.executeUpdate();\r\n            pstmt.close();\r\n            connection.close();\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return count;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        DeleteRecord deleteRecord = new DeleteRecord();\r\n        int count = deleteRecord.deleteOneStudent(\"9527\");\r\n        System.out.println(count);\r\n    }\r\n}\r\n\r\n```\r\n### 总结\r\n\r\n> 我在表里面放了很多Sno=9527的行，都被删除了，count返回的就是被删除的行数。在PrepareStatement（String）中的String就是进行预编译。至于为什么老是喜欢使用executeUpdate()而不是execute()，是因为我们想要知道操作语句执行表中的行数，而不是一个简简单单的成功不成功。当然也可以在错误的时候返回不成功，这些不成功的值都是可以自己设置，如果不知道本身不成功返回的话。考虑了一下为什么要把getConnection（）与后面的产生Statement语句放在一个块儿里，因为都会报错，放两个地方会有两个try块，多不美观，。，。\r\n\r\n\r\n## 数据信息的修改\r\n```java\r\n\r\n/**\r\n * Created by XQF on 2016/12/2.\r\n */\r\npublic class UpdateRecord {\r\n    private Connection connection;\r\n    private PreparedStatement pstmt;\r\n    private static final String sqlString = \"update students set Sage=Sage+1\";\r\n//    private static final String sqlString = \"update students set age=age+1\";\r\n//这里就是设计错误报告的重要性，刚开始我使用下面这个语句给我报错说是数据库读异常\r\n    public int updateStudentDataInfo() {\r\n        int count = -1;\r\n        connection = new DBConnection().getConnection();\r\n        try {\r\n            pstmt = connection.prepareStatement(sqlString);\r\n            count = pstmt.executeUpdate();\r\n            connection.close();\r\n            pstmt.close();\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读异常！\"+e.getMessage());\r\n        }\r\n        return count;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        UpdateRecord updateRecord=new UpdateRecord();\r\n        int count=updateRecord.updateStudentDataInfo();\r\n        System.out.println(count);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 总结\r\n\r\n返回的结果是3，本来表中就只有三行，每一行的Sage都改变了，executeUpdate()返回的是操作的数据行数。\r\n\r\n## 数据信息的查询\r\n```java\r\n\r\n/**\r\n * Created by XQF on 2016/12/2.\r\n */\r\npublic class QueryStudent {\r\n    private Connection connection;\r\n    private PreparedStatement pstmt;\r\n    private ResultSet resultSet;\r\n\r\n\r\n    public void getOneStudentInfo(String Sno) {\r\n        connection = new DBConnection().getConnection();\r\n        String sqlString = \"select * from students where Sno=?\";\r\n        try {\r\n            pstmt = connection.prepareStatement(sqlString);\r\n            pstmt.setString(1, Sno);\r\n            resultSet = pstmt.executeQuery();\r\n            while (resultSet.next()) {\r\n                System.out.println(resultSet.getString(1) + \" \" + resultSet.getString(2) + \" \" + resultSet.getInt(3) + \" \" + resultSet.getString(4));\r\n            }\r\n            pstmt.close();\r\n            connection.close();\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读错误\" + e.getMessage());\r\n        }\r\n\r\n    }\r\n\r\n    public void getAllStudentsInfo() {\r\n        connection = new DBConnection().getConnection();\r\n        String sqlString = \"select * from students\";\r\n        try {\r\n            pstmt = connection.prepareStatement(sqlString);\r\n            resultSet = pstmt.executeQuery();\r\n            while (resultSet.next()) {\r\n                System.out.println(resultSet.getString(1) + \" \" + resultSet.getString(2) + \" \" + resultSet.getInt(3) + \" \" + resultSet.getString(4));\r\n            }\r\n        } catch (SQLException e) {\r\n            System.out.println(\"数据库读错误\" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        QueryStudent queryStudent = new QueryStudent();\r\n        queryStudent.getOneStudentInfo(\"130063\");\r\n        System.out.println(\"-------------------------------------------------------------\");\r\n        queryStudent.getAllStudentsInfo();\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 总结\r\n\r\n> 每个单一的动作都要加上一句获取连接（当然可以在创建动作抽象类的时候在构造方法中初始化），但是不安全呀。想着每一个动作完成就关闭数据库。虽然是耗时了一点但是比较安全呀。\r\n\r\n\r\n\r\n## 国际惯例：总结\r\n基本上把简单的操作都走了一遍，不过基本上没有什么复杂的，就是一个sql与java的组合。sql的核心就是语句，因为java提供的API使得你只需要把sql语句组合成String就行了。但是套路也是比较多呀，怎么才能降低耦合度，通用性和复用性更广，这就是在设计的过程中不断重构了来解决了。还有就是涉及控制台或者AWT语句的输入。\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}